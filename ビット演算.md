## 2進数いろいろ

ほとんどのコンピュータは、2進数で計算をします。

10進数の場合は、ゼロは0、1は1、9は9、9の次は繰り上がって10になります。

2進数の場合は、ゼロは0、1は1、2は2とはならずに桁が繰り上がって、10になります。10と記述すると10進数の10なのか、2進数の2なのか分からないので0b10や、0b0010と記述します。0bのbはbinaryのbです。binaryっていうのは「2値の」という意味らしいです。

要は、電気のON/OFFで1/0を表しています。電気入れかけで2とか、切りかけで9といった微妙な操作はできないので、白黒はっきりする0/1で計算しています。

## ビット演算

コンピュータの得意な計算として、ビット演算があります。コンピュータには都合が良いですが、人間には慣れが必要です。

### AND演算

A and B と計算をした場合、Aの内容が1、かつ、Bの内容も1、だけが1で残ります。例えば、
```
    0b0001 0011
and 0b1111 0101
-----------------
    0b0001 0001
```
となります。rubyでは
```
irb(main):001:0> 0b0001 & 0b1111
=> 1
irb(main):002:0> 0b0011 & 0b0101
=> 1
irb(main):003:0> 
```
となります。

### OR演算

A or B と計算をした場合、Aの内容が1、か、Bの内容が1、が1で残ります。
例えば、
```
   0b0001 0011
or 0b1111 0101
----------------
   0b1111 0111
```
となります。rubyでは
```
irb(main):003:0> 0b0001 | 0b1111
=> 15
irb(main):004:0> 0b0011 | 0b0101
=> 7
```
となります。ただ結果はあっているのですが、15とか7になってますね。

15というのは、すでに2進数ではなく10進数になっています。7もわかりづらいですが10進数で表示されています。

### 2進数と10進数、16進数の対応表

| 2進数 | 10進数 | 16進数 |
|--:|--:|--:|
| 0b0000 | 0 | 0x0 |
| 0b0001 | 1 | 0x1 |
| 0b0010 | 2 | 0x2 |
| 0b0011 | 3 | 0x3 |
| 0b0100 | 4 | 0x4 |
| 0b0101 | 5 | 0x5 |
| 0b0110 | 6 | 0x6 |
| 0b0111 | 7 | 0x7 |
| 0b1000 | 8 | 0x8 |
| 0b1001 | 9 | 0x9 |
| 0b1010 | 10 | 0xA |
| 0b1011 | 11 | 0xB |
| 0b1100 | 12 | 0xC |
| 0b1101 | 13 | 0xD |
| 0b1110 | 14 | 0xE |
| 0b1111 | 15 | 0xF |
| 0b0001 0000 | 16 | 0x10 |
| 0b0010 0000 | 32 | 0x20 |
| 0b0100 0000 | 64 | 0x40 |
| 0b1000 0000 | 128 | 0x80 |

10進数の15は2進数では0b1111、10進数の7は2進数では0b0111ですね。今まで、0b1111と書いてきましたが、桁数が4桁ぐらいなら飽きずにかけますが、16桁になると0b1111 0b1111 0b1111 0b1111になり、正しく記述できているのかさえ、もうわかりません。そこで多くの場合は、2進数では表記せずに16進数で表記します。0x????と表記しますが、0xのxはhexadecimalのx?

なお、16進数の場合は、0から9では表現が不足するので、9の次からはAからFを利用します。

例えば、0b1111 0b0100 0b0010 0b0001は16進数で表記すると0xF421となります。

Rubyで2進数に変換して表示した方がわかりやすい場合は
```
irb(main):003:0> (0b0001 | 0b1111).to_s(2)
=> "1111"
```
とすることで文字列になりますが、2進数での表記を確認できます。
```
irb(main):004:0> (0b0001 | 0b1111).to_s(16)
=> "f"
```
とすることで、16進数での表記を確認できます。大文字での表示が必要なら
```
irb(main):008:0> (0b0001 | 0b1111).to_s(16).upcase
=> "F"
```
で変換できます。が、今回は`f`を求めたいだけなのでちょっとやりすぎです。

蛇足ですが、メモリや記憶装置のサイズが16GBとか32GBとか10進数では人には切りの悪い数字ですが、コンピュータとしては、2,4,8,16,32や512,1024などは切りのいい数字なのです。

### シフト演算

シフト演算というのは、桁上げ、桁下げです。

たとえば、左シフト(桁上げ)の場合、10進数で9000の10倍は90000になります。2進数で0b0010(2)の2倍は0b0100(4)になります。

Rubyで記述すると
```
irb(main):018:0> 2 << 1
=> 4
irb(main):019:0> (0b0010 << 1).to_s(2)
=> "100"
irb(main):020:0> 0b100
=> 4
```
となります。イメージとしては、0b0010 => 0b010? => ?はゼロで埋める、という計算が行われます。
コンピュータの内部で確保した変数(値を記憶するハコ)の大きさによって、0b1000を1ビット左シフトすると0b0000になったり、0b0001 0000になったりします。
0b0000になる場合は桁溢れした場合、Rubyの場合は、0b0001 0000になります。0b????で桁数をとどめたい場合は、0b1111でand演算をします。
```
irb(main):032:0> (0b1000 << 1) & 0b1111
=> 0
```

Rubyで右シフト(桁下げ)を記述すると
```
irb(main):021:0> 64 >> 2
=> 16
irb(main):022:0> (0b1000000 >> 2).to_s(2)
=> "10000"
irb(main):023:0> 0b10000
=> 16
```
となります。64の1/2が32、その1/2で16ですね。
